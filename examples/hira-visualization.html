<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EmptyAddress Network Autonomy Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            height: 100vh;
            overflow: hidden;
        }
        #container {
            display: flex;
            gap: 20px;
            width: 100%;
            height: calc(100vh - 60px);
        }
        #canvas-container {
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #controls {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            width: 320px;
            height: 100%;
            overflow-y: auto;
            flex-shrink: 0;
        }
        h1 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 24px;
            text-align: center;
        }
        h2 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
        }
        .stat {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
        .stat-label {
            font-weight: bold;
            color: #666;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .legend {
            margin-top: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <h1>EmptyAddress Network Autonomy Simulation</h1>
    <div id="container">
        <div id="canvas-container"></div>
        <div id="controls">
            <h2>Controls</h2>
            <button id="startBtn">Start Simulation</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="resetBtn">Reset</button>
            
            <h2>Statistics</h2>
            <div class="stat">
                <span class="stat-label">Step:</span>
                <span id="stepCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Average Autonomy:</span>
                <span id="avgAutonomy">20.0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Exploitation Links:</span>
                <span id="exploitCount">0</span>
            </div>
            <div class="stat">
                <span class="stat-label">Support Links:</span>
                <span id="supportCount">0</span>
            </div>
            
            <div class="legend">
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #ff6b6b;"></div>
                    <span>Vulnerable Person</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #333;"></div>
                    <span>Trafficker</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #4ecdc4;"></div>
                    <span>Support Worker</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #f7b731;"></div>
                    <span>Community Leader</span>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Import compiled AgentJS
        import { 
            BaseAgent, 
            NetworkAgent,
            AgentManager, 
            ContinuousSpace, 
            RandomScheduler,
            NetworkManager
        } from '../dist/index.es.js';

        // Agent types
        const AgentType = {
            VULNERABLE: 'vulnerable',
            TRAFFICKER: 'trafficker',
            SUPPORT_WORKER: 'support_worker',
            COMMUNITY_LEADER: 'community_leader'
        };

        // Connection types
        const ConnectionType = {
            EXPLOITATION: 'exploitation',
            SUPPORT: 'support',
            COMMUNITY: 'community'
        };

        // Custom EmptyAddress Agent
        class EmptyAddressAgent extends NetworkAgent {
            constructor(id, type, x, y) {
                super(id, {
                    type,
                    autonomy: type === AgentType.VULNERABLE ? 20 : 80,
                    resources: type === AgentType.VULNERABLE ? 30 : 70,
                    awareness: type === AgentType.VULNERABLE ? 10 : 50
                });
                // Use internal position storage to avoid readonly issues
                this._position = { x, y };
                this.targetPos = { x, y };
            }

            get position() {
                return this._position;
            }

            set position(newPos) {
                this._position = newPos;
            }

            step() {
                super.step();
                
                // Update autonomy based on connections
                const connections = this.networkManager?.getConnections(this.id);
                if (connections) {
                    let autonomyChange = 0;
                    
                    for (const conn of connections) {
                        switch (conn.type) {
                            case ConnectionType.EXPLOITATION:
                                autonomyChange -= 0.5;
                                break;
                            case ConnectionType.SUPPORT:
                                autonomyChange += 0.3;
                                break;
                            case ConnectionType.COMMUNITY:
                                autonomyChange += 0.1;
                                break;
                        }
                    }
                    
                    const currentAutonomy = this.getProperty('autonomy');
                    this.setProperty('autonomy', Math.max(0, Math.min(100, currentAutonomy + autonomyChange)));
                }
                
                // Move based on forces
                this.updateMovement();
            }
            
            updateMovement() {
                const neighbors = this.environment?.getNeighbors(this._position, 100);
                if (!neighbors) return;
                
                let forceX = 0;
                let forceY = 0;
                
                for (const neighbor of neighbors.agents) {
                    const dx = neighbor._position.x - this._position.x;
                    const dy = neighbor._position.y - this._position.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0 && dist < 100) {
                        const myType = this.getProperty('type');
                        const theirType = neighbor.getProperty('type');
                        
                        if (myType === AgentType.VULNERABLE && theirType === AgentType.TRAFFICKER) {
                            // Repel from traffickers
                            forceX -= (dx / dist) * 2;
                            forceY -= (dy / dist) * 2;
                        } else if (theirType === AgentType.SUPPORT_WORKER) {
                            // Attract to support workers
                            forceX += (dx / dist) * 0.5;
                            forceY += (dy / dist) * 0.5;
                        }
                    }
                }
                
                // Add some random movement
                forceX += (Math.random() - 0.5) * 0.5;
                forceY += (Math.random() - 0.5) * 0.5;
                
                // Update position with momentum
                this.targetPos.x += forceX;
                this.targetPos.y += forceY;
                
                // Smooth movement
                this._position.x += (this.targetPos.x - this._position.x) * 0.1;
                this._position.y += (this.targetPos.y - this._position.y) * 0.1;
                
                // Keep in bounds (using environment dimensions)
                const envWidth = this.environment?.width || 800;
                const envHeight = this.environment?.height || 600;
                this._position.x = Math.max(20, Math.min(envWidth - 20, this._position.x));
                this._position.y = Math.max(20, Math.min(envHeight - 20, this._position.y));
            }
        }

        // Global variables
        let environment, agentManager, networkManager, scheduler;
        let isRunning = false;
        let step = 0;

        // p5.js sketch
        const sketch = (p) => {
            p.setup = () => {
                // Get container dimensions
                const container = document.getElementById('canvas-container');
                const containerRect = container.getBoundingClientRect();
                const canvasWidth = Math.max(600, containerRect.width - 40);
                const canvasHeight = Math.max(400, containerRect.height - 40);
                
                const canvas = p.createCanvas(canvasWidth, canvasHeight);
                canvas.parent('canvas-container');
                
                // Initialize simulation
                resetSimulation();
            };

            p.draw = () => {
                p.background(245);
                
                // Draw connections
                p.strokeWeight(1);
                const connections = networkManager.getAllConnections();
                for (const conn of connections) {
                    const fromAgent = agentManager.getAgent(conn.source);
                    const toAgent = agentManager.getAgent(conn.target);
                    
                    if (fromAgent && toAgent) {
                        switch (conn.type) {
                            case ConnectionType.EXPLOITATION:
                                p.stroke(255, 0, 0, 100);
                                break;
                            case ConnectionType.SUPPORT:
                                p.stroke(0, 255, 0, 100);
                                break;
                            case ConnectionType.COMMUNITY:
                                p.stroke(0, 0, 255, 100);
                                break;
                        }
                        
                        p.line(
                            fromAgent._position.x, fromAgent._position.y,
                            toAgent._position.x, toAgent._position.y
                        );
                    }
                }
                
                // Draw agents
                p.noStroke();
                for (const agent of agentManager.getAllAgents()) {
                    const type = agent.getProperty('type');
                    const autonomy = agent.getProperty('autonomy');
                    
                    // Set color based on type
                    switch (type) {
                        case AgentType.VULNERABLE:
                            p.fill(255, 107, 107); // Red
                            break;
                        case AgentType.TRAFFICKER:
                            p.fill(51, 51, 51); // Dark
                            break;
                        case AgentType.SUPPORT_WORKER:
                            p.fill(78, 205, 196); // Teal
                            break;
                        case AgentType.COMMUNITY_LEADER:
                            p.fill(247, 183, 49); // Gold
                            break;
                    }
                    
                    // Size based on autonomy
                    const size = 10 + (autonomy / 100) * 10;
                    p.circle(agent._position.x, agent._position.y, size);
                    
                    // Show autonomy for vulnerable agents
                    if (type === AgentType.VULNERABLE) {
                        p.fill(0);
                        p.textAlign(p.CENTER);
                        p.textSize(10);
                        p.text(Math.round(autonomy), agent._position.x, agent._position.y - 10);
                    }
                }
                
                // Run simulation step
                if (isRunning) {
                    scheduler.step();
                    step++;
                    updateStats();
                }
            };
        };

        function resetSimulation() {
            // Get canvas dimensions for dynamic sizing
            const canvas = document.querySelector('#canvas-container canvas');
            const canvasWidth = canvas ? canvas.width : 800;
            const canvasHeight = canvas ? canvas.height : 600;
            
            // Initialize core components
            environment = new ContinuousSpace({
                width: canvasWidth,
                height: canvasHeight,
                boundaryType: 'reflective'
            });
            
            agentManager = new AgentManager();
            networkManager = new NetworkManager();
            scheduler = new RandomScheduler();
            
            step = 0;
            
            // Create agents
            // Vulnerable population
            for (let i = 0; i < 20; i++) {
                const agent = new EmptyAddressAgent(
                    `vulnerable_${i}`,
                    AgentType.VULNERABLE,
                    Math.random() * (canvasWidth - 40) + 20,
                    Math.random() * (canvasHeight - 40) + 20
                );
                agent.environment = environment;
                agent.networkManager = networkManager;
                agentManager.addAgent(agent);
                scheduler.addAgent(agent);
                environment.addAgent(agent);
            }
            
            // Traffickers
            for (let i = 0; i < 3; i++) {
                const agent = new EmptyAddressAgent(
                    `trafficker_${i}`,
                    AgentType.TRAFFICKER,
                    Math.random() * (canvasWidth - 40) + 20,
                    Math.random() * (canvasHeight - 40) + 20
                );
                agent.environment = environment;
                agent.networkManager = networkManager;
                agentManager.addAgent(agent);
                scheduler.addAgent(agent);
                environment.addAgent(agent);
            }
            
            // Support workers
            for (let i = 0; i < 5; i++) {
                const agent = new EmptyAddressAgent(
                    `support_${i}`,
                    AgentType.SUPPORT_WORKER,
                    Math.random() * (canvasWidth - 40) + 20,
                    Math.random() * (canvasHeight - 40) + 20
                );
                agent.environment = environment;
                agent.networkManager = networkManager;
                agentManager.addAgent(agent);
                scheduler.addAgent(agent);
                environment.addAgent(agent);
            }
            
            // Community leaders
            for (let i = 0; i < 2; i++) {
                const agent = new EmptyAddressAgent(
                    `leader_${i}`,
                    AgentType.COMMUNITY_LEADER,
                    (canvasWidth / 2) + Math.random() * 100 - 50,
                    (canvasHeight / 2) + Math.random() * 100 - 50
                );
                agent.environment = environment;
                agent.networkManager = networkManager;
                agentManager.addAgent(agent);
                scheduler.addAgent(agent);
                environment.addAgent(agent);
            }
            
            // Form initial networks
            const vulnerableAgents = agentManager.queryAgents({ 
                property: 'type', 
                propertyValue: AgentType.VULNERABLE 
            });
            const traffickers = agentManager.queryAgents({ 
                property: 'type', 
                propertyValue: AgentType.TRAFFICKER 
            });
            const supportWorkers = agentManager.queryAgents({ 
                property: 'type', 
                propertyValue: AgentType.SUPPORT_WORKER 
            });
            
            // Traffickers target vulnerable agents
            for (const trafficker of traffickers) {
                const targets = vulnerableAgents
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 2 + Math.floor(Math.random() * 2));
                
                for (const target of targets) {
                    networkManager.addConnection(
                        trafficker.id,
                        target.id,
                        ConnectionType.EXPLOITATION,
                        0.8
                    );
                }
            }
            
            // Support workers help vulnerable agents
            for (const worker of supportWorkers) {
                const helped = vulnerableAgents
                    .sort(() => Math.random() - 0.5)
                    .slice(0, 3 + Math.floor(Math.random() * 2));
                
                for (const agent of helped) {
                    networkManager.addConnection(
                        worker.id,
                        agent.id,
                        ConnectionType.SUPPORT,
                        0.6
                    );
                }
            }
            
            updateStats();
        }

        function updateStats() {
            document.getElementById('stepCount').textContent = step;
            
            const vulnerableAgents = agentManager.queryAgents({ 
                property: 'type', 
                propertyValue: AgentType.VULNERABLE 
            });
            
            const avgAutonomy = vulnerableAgents.reduce((sum, agent) => 
                sum + agent.getProperty('autonomy'), 0
            ) / vulnerableAgents.length;
            
            document.getElementById('avgAutonomy').textContent = avgAutonomy.toFixed(1);
            
            const connections = Array.from(networkManager.getAllConnections());
            const exploitCount = connections.filter(c => c.type === ConnectionType.EXPLOITATION).length;
            const supportCount = connections.filter(c => c.type === ConnectionType.SUPPORT).length;
            
            document.getElementById('exploitCount').textContent = exploitCount;
            document.getElementById('supportCount').textContent = supportCount;
        }

        // Controls
        document.getElementById('startBtn').addEventListener('click', () => {
            isRunning = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
        });
        
        document.getElementById('pauseBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            resetSimulation();
        });

        // Initialize p5
        new p5(sketch);
    </script>
</body>
</html>